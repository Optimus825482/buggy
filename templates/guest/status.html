{% extends "base.html" %}

{% block title %}Talep Durumu{% endblock %}

{% block extra_css %}
<style>
    .header {
        display: none;
    }
    .footer {
        display: none;
    }
    .status-container {
        min-height: calc(100vh - 200px);
        display: flex;
        align-items: center;
        justify-content: center;
        padding: var(--spacing-xl) var(--spacing-md);
        background: linear-gradient(135deg, var(--primary-light) 0%, var(--primary-color) 100%);
    }

    .status-card {
        width: 100%;
        max-width: 600px;
        box-shadow: var(--shadow-xl);
    }

    .status-icon {
        font-size: 4rem;
        margin: 2rem 0;
    }

    .spinner {
        border: 4px solid rgba(0, 0, 0, 0.1);
        border-left-color: var(--primary-color);
        border-radius: 50%;
        width: 60px;
        height: 60px;
        animation: spin 1s linear infinite;
        margin: 2rem auto;
    }

    @keyframes spin {
        to {
            transform: rotate(360deg);
        }
    }

    .progress-ring {
        width: 150px;
        height: 150px;
        margin: 2rem auto;
    }
</style>
{% endblock %}

{% block content %}
<div class="status-container">
    <div class="status-card card">
        <div class="card-header text-center" style="background: var(--primary-color); color: white;">
            <h2><i class="fas fa-route"></i> Talep Durumu</h2>
            <span id="status-badge" class="badge badge-warning">YÃ¼kleniyor...</span>
        </div>

        <div class="card-body text-center">
            <!-- Pending Status -->
            <div id="status-pending" class="status-view">
                <div class="spinner"></div>
                <h3>Buggy Ã§aÄŸrÄ±lÄ±yor...</h3>
                <p class="text-muted">LÃ¼tfen bekleyin, size en yakÄ±n buggy yÃ¶nlendirilecek</p>
            </div>

            <!-- Accepted Status -->
            <div id="status-accepted" class="status-view d-none">
                <i class="fas fa-check-circle status-icon" style="color: var(--success-color);"></i>
                <h3>Buggy Yolda!</h3>
                <p class="text-muted">Buggy'niz size doÄŸru geliyor</p>
                <div id="buggy-info" class="alert alert-info mt-3"></div>
            </div>

            <!-- Completed Status -->
            <div id="status-completed" class="status-view d-none">
                <i class="fas fa-star status-icon" style="color: var(--accent-color);"></i>
                <h3>TeÅŸekkÃ¼rler!</h3>
                <p class="text-muted">Buggy'niz geldi. Ä°yi gÃ¼nler!</p>
                <div id="timing-info" class="alert alert-success mt-3"></div>
            </div>

            <!-- Cancelled Status -->
            <div id="status-cancelled" class="status-view d-none">
                <i class="fas fa-times-circle status-icon" style="color: var(--danger-color);"></i>
                <h3>Talep Ä°ptal Edildi</h3>
                <p class="text-muted">Ä°sterseniz yeni bir talep oluÅŸturabilirsiniz</p>
            </div>

            <!-- Location Info -->
            <div id="location-info" class="mt-3"></div>
        </div>

        <div class="card-footer text-center">
            <button id="cancel-btn" class="btn btn-danger" onclick="cancelRequest()">
                <i class="fas fa-times"></i> Ä°ptal Et
            </button>
            <button id="new-request-btn" class="btn btn-primary d-none" onclick="newRequest()">
                <i class="fas fa-plus"></i> Yeni Talep
            </button>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    const requestId = {{ request_id }};
    let socket = null;
    let pollInterval = null;

    document.addEventListener( 'DOMContentLoaded', () => {
        initStatusTracking();
    } );

    function initStatusTracking() {
        // Initialize Socket.IO directly
        if (typeof io === 'undefined') {
            console.error('Socket.IO not loaded');
            // Fallback to polling only
            loadRequestStatus();
            pollInterval = setInterval( loadRequestStatus, 3000 );
            return;
        }
        
        socket = io({
            transports: ['polling', 'websocket'],
            reconnection: true,
            reconnectionDelay: 1000,
            reconnectionAttempts: 5
        });

        socket.on( 'connect', () => {
            console.log( 'Socket connected for request:', requestId );
            // Join request room
            socket.emit( 'join_request', { request_id: requestId } );
        } );
        
        socket.on( 'joined_request', (data) => {
            console.log('Joined request room:', data);
        } );

        // Listen to status updates
        socket.on( 'request_accepted', ( data ) => {
            console.log('Received request_accepted event:', data);
            if ( data.request_id === requestId ) {
                console.log('Request accepted! Updating status...');
                updateStatus( 'accepted', data );
                // Show acceptance notification
                showAcceptanceNotification( data );
            } else {
                console.log('Request ID mismatch:', data.request_id, 'vs', requestId);
            }
        } );

        socket.on( 'request_completed', ( data ) => {
            if ( data.request_id === requestId ) {
                updateStatus( 'completed', data );
            }
        } );

        socket.on( 'request_cancelled', ( data ) => {
            if ( data.request_id === requestId ) {
                updateStatus( 'cancelled', data );
            }
        } );

        // Start polling as backup
        loadRequestStatus();
        pollInterval = setInterval( loadRequestStatus, 5000 );
    }

    async function loadRequestStatus() {
        try {
            const response = await fetch( `/api/requests/${requestId}` );
            const data = await response.json();

            if ( data.success && data.request ) {
                console.log('Polling - current status:', data.request.status);
                updateStatus( data.request.status, data.request );
            } else {
                console.error('Failed to load request status:', data);
            }
        } catch ( error ) {
            console.error( 'Error loading request status:', error );
        }
    }

    function updateStatus( status, data ) {
        console.log('Updating status to:', status, 'with data:', data);
        
        // Hide all status views
        document.querySelectorAll( '.status-view' ).forEach( el => el.classList.add( 'd-none' ) );

        // Show current status view
        const statusView = document.getElementById( `status-${status}` );
        if ( statusView ) {
            statusView.classList.remove( 'd-none' );
            console.log('Status view updated to:', status);
        } else {
            console.error('Status view not found for:', status);
        }

        // Update badge
        const badge = document.getElementById( 'status-badge' );
        if ( badge ) {
            badge.className = `badge ${getBadgeClass( status )}`;
            badge.textContent = getStatusText( status );
        }

        // Update specific info
        if ( status === 'accepted' && data.buggy ) {
            const buggyInfo = document.getElementById( 'buggy-info' );
            if ( buggyInfo ) {
                buggyInfo.innerHTML = `
                    <strong><i class="fas fa-truck-pickup"></i> Buggy:</strong> ${data.buggy.code || 'N/A'}<br>
                    ${data.driver ? `<strong><i class="fas fa-user"></i> SÃ¼rÃ¼cÃ¼:</strong> ${data.driver.full_name || 'N/A'}` : ''}
                `;
            }
        }

        if ( status === 'completed' && data.response_time_seconds ) {
            const timingInfo = document.getElementById( 'timing-info' );
            if ( timingInfo ) {
                const minutes = Math.floor( data.response_time_seconds / 60 );
                timingInfo.innerHTML = `
                    <strong><i class="fas fa-clock"></i> Toplam SÃ¼re:</strong> ${minutes} dakika
                `;
            }
        }

        // Update buttons
        const cancelBtn = document.getElementById( 'cancel-btn' );
        const newRequestBtn = document.getElementById( 'new-request-btn' );

        if ( ['completed', 'cancelled'].includes( status ) ) {
            if ( cancelBtn ) cancelBtn.classList.add( 'd-none' );
            if ( newRequestBtn ) newRequestBtn.classList.remove( 'd-none' );
            // Stop polling
            if ( pollInterval ) {
                clearInterval( pollInterval );
            }
        }

        // Show location info
        if ( data.location ) {
            const locationInfo = document.getElementById( 'location-info' );
            if ( locationInfo ) {
                locationInfo.innerHTML = `
                    <small class="text-muted">
                        <i class="fas fa-map-marker-alt"></i> ${data.location.name}
                        ${data.room_number ? ` â€¢ Oda: ${data.room_number}` : ''}
                    </small>
                `;
            }
        }
    }

    async function cancelRequest() {
        if ( !confirm( 'Talebi iptal etmek istediÄŸinize emin misiniz?' ) ) {
            return;
        }

        try {
            const response = await fetch( `/api/requests/${requestId}/cancel`, {
                method: 'POST'
            } );
            const data = await response.json();

            if ( data.success ) {
                BuggyCall.Utils.showToast( 'Talep iptal edildi', 'success' );
                updateStatus( 'cancelled', {} );
            } else {
                BuggyCall.Utils.showToast( data.error || 'Ä°ptal edilemedi', 'danger' );
            }
        } catch ( error ) {
            console.error( 'Error cancelling request:', error );
            BuggyCall.Utils.showToast( 'Bir hata oluÅŸtu', 'danger' );
        }
    }

    function newRequest() {
        window.location.href = '/guest/call';
    }

    function getBadgeClass( status ) {
        const map = {
            'pending': 'badge-warning',
            'accepted': 'badge-info',
            'completed': 'badge-success',
            'cancelled': 'badge-danger'
        };
        return map[status] || 'badge-secondary';
    }

    function getStatusText( status ) {
        const map = {
            'pending': 'Bekliyor',
            'accepted': 'Kabul Edildi',
            'completed': 'TamamlandÄ±',
            'cancelled': 'Ä°ptal Edildi'
        };
        return map[status] || status;
    }

    function showAcceptanceNotification( data ) {
        // Get buggy code
        const buggyCode = data.buggy?.code || 'Buggy';
        const driverName = data.driver?.full_name || '';
        
        // Create notification message
        let message = `ðŸŽ‰ Talebiniz ${buggyCode} numaralÄ± buggy tarafÄ±ndan kabul edildi!`;
        if ( driverName ) {
            message += `\n\nSÃ¼rÃ¼cÃ¼: ${driverName}`;
        }
        message += '\n\nBuggy size doÄŸru geliyor...';
        
        // Show alert notification
        alert( message );
        
        // Play notification sound
        playAcceptanceSound();
        
        // Vibrate if supported
        if ( window.navigator && window.navigator.vibrate ) {
            window.navigator.vibrate( [200, 100, 200] );
        }
        
        // Show browser notification if permitted
        if ( 'Notification' in window && Notification.permission === 'granted' ) {
            new Notification( 'Buggy Kabul Edildi! ðŸŽ‰', {
                body: `${buggyCode} size doÄŸru geliyor`,
                icon: '/static/icons/icon-192x192.png',
                badge: '/static/icons/icon-96x96.png',
                vibrate: [200, 100, 200]
            } );
        }
    }

    function playAcceptanceSound() {
        try {
            // Use Web Audio API to generate success sound
            const audioContext = new ( window.AudioContext || window.webkitAudioContext )();
            
            // Play ascending tones for success
            const frequencies = [523, 659, 784]; // C, E, G (major chord)
            
            frequencies.forEach( ( freq, index ) => {
                setTimeout( () => {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect( gainNode );
                    gainNode.connect( audioContext.destination );
                    
                    oscillator.frequency.value = freq;
                    oscillator.type = 'sine';
                    
                    gainNode.gain.setValueAtTime( 0, audioContext.currentTime );
                    gainNode.gain.linearRampToValueAtTime( 0.2, audioContext.currentTime + 0.01 );
                    gainNode.gain.exponentialRampToValueAtTime( 0.01, audioContext.currentTime + 0.3 );
                    
                    oscillator.start( audioContext.currentTime );
                    oscillator.stop( audioContext.currentTime + 0.3 );
                }, index * 150 );
            } );
        } catch ( error ) {
            console.error( 'Error playing acceptance sound:', error );
        }
    }
</script>
{% endblock %}